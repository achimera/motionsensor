/*
Wireless PIR sensor Transmitter firmware
 revision 1.0
 Copyright (c) 2014, Andrey Shigapov, All rights reserved
 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU General Public License for more details.
 http://www.gnu.org/licenses/gpl.txt
 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
 /*
 08/11/2014 - Added photoresistor to sense the light and a trimmer to determine when
              the transmitter should send a motion detection
 09/11/2014 - Added struct for nodeId
 */
/////////////////////////////////////////////////////////////////////////////////////////////
// This program puts MCU in sleep mode and uses two interrupts to process events in order to save energy
// The first interrupt is generated by PIR sensor output connected to D2 input, the interrupt handler schedules
// transmission of a single byte command with ASCII value of 'o' and disables PIR sensor for a number of WDT interrupts
// The second interrupt is generated by WDT and it fires about every 8 sec.
// This interrupt handler decreases PIR sensor disable counter
/////////////////////////////////////////////////////////////////////////////////////////////
#include <avr/sleep.h>
#include <avr/power.h>
#include <SPI.h>
#include "nRF24L01.h"
#include "RF24.h"
#include "printf.h"

#define VERSION    0.5 //version
#define ENABLE_SERIAL //enable the debug 

#define NODEID     101 //unique for each node on same network
#define NETWORKID  101 //the same on all nodes that talk to each other
#define GATEWAYID    1
// 
#define PIR_DISABLE_INTERVAL 1
// Photo cell
#define PHOTO_CELL_PIN 0   // Analog I/O pin for photo cell input
#define PHOTO_CELL_POWER A2 // Analog I/O pin for photo cell power
#define LIGHT_THRESHOLD_PIN A1 // Analog I/O pin to set the light threshold

//struct for wireless data transmission
typedef struct {
  int nodeID;             //node ID (1xx, 2xx, 3xx); 1xx = hall, 2xx = main floor, 3xx = outside
  int deviceID;           //sensor ID (2, 3, 4, 5)
  unsigned long var1_usl; //uptime in msecs
  float var2_float;       //may contain sensor data
  float var3_float;       //may contain more sensor data
} Payload;
Payload sensorData;

#define STATUS_LED A3 // the pin that the LED is attached to
#define PIR_INPUT 2 // the pin that is connected to PIT output

#define ledRx STATUS_LED //for now is the same as status
#define ledTx STATUS_LED //for now is the same as status
uint8_t pir_disable_counter = 1;  //disable the sensor for the first 8 sec, let all transition precesses to settle down
uint8_t pir_enable_counter = 0;

// Set up nRF24L01 radio on SPI bus plus pins 9 & 10
RF24 radio(9,10);
// Radio pipe addresses for the 2 nodes to communicate.
const uint64_t pipes[2] = { 0xE7E7E7E700LL, 0xE7E7E7E700LL }; // !!! DO NOT THIS COMMIT VALUE !!!

uint8_t dataToSend = 0;
uint8_t dataSent = 0;
uint16_t lightThreshold = 0;

//timings
unsigned long pir_time;
unsigned long light_time;

void openPipes()
{
  uint64_t txPipe = pipes[0];
  uint64_t rxPipe = pipes[1];
  radio.openWritingPipe(txPipe);
  radio.openReadingPipe(1, rxPipe);
}

/////////////////////////////////////////////////////////////////
// Returns: Nothing.
// Parameters: None.
//
// Description: PIR output signal Interrupt Service.
// This is executed when PIR sensor sense a movement,
// it disables the PIR sensor for several WDT intervals
// in order to conserve the energy
/////////////////////////////////////////////////////////////////
ISR(PIR_vect)
{
  if(pir_disable_counter == pir_enable_counter) {
    pir_disable_counter += PIR_DISABLE_INTERVAL;
    dataToSend++; 
  }
}
/////////////////////////////////////////////////////////////////
// Returns: Nothing.
// Parameters: None.
//
// Description: Watchdog Interrupt Service. This
// is executed when watchdog timed out,
// approximately every 8 seconds
/////////////////////////////////////////////////////////////////
ISR(WDT_vect)
{
  if(pir_disable_counter != pir_enable_counter) {
    pir_enable_counter += 1;
  }
}
/////////////////////////////////////////////////////////////////
// Returns: Nothing.
// Parameters: None.
//
// Description: Enters the arduino into sleep mode.
/////////////////////////////////////////////////////////////////
void PowerDownSleep(void)
{
  set_sleep_mode(SLEEP_MODE_PWR_DOWN); /* EDIT: could also use SLEEP_MODE_PWR_DOWN for lowest power consumption. */
  sleep_enable();
  //turn off peripherals
  volatile uint8_t old_ADCSRA = ADCSRA;
  ADCSRA = 0;
  PRR = 0
    | (1<<PRTWI) // turn off TWI
      | (1<<PRTIM0) // turn off Timer/Counter0
        | (1<<PRTIM1) // turn off Timer/Counter1 (leave Timer/Counter2 on)
        | (1<<PRSPI) // turn off SPI
            | (1<<PRUSART0) // turn off USART (will turn on again when reset)
            | (1<<PRADC) // turn off ADC
                | 0;
  //shut off BOD:
  MCUCR = _BV (BODS) | _BV (BODSE); // turn on brown-out enable select
  MCUCR = _BV (BODS); // this must be done within 4 clock cycles of above
  // Now enter sleep mode.
  sleep_cpu();
  // The program will continue from here after the WDT timeout
  // First thing to do is disable sleep.
  sleep_disable();
  // Re-enable the peripherals.
  power_all_enable();
  ADCSRA = old_ADCSRA; //re-enable the analog2digital converter 
  PRR = 0
#ifndef ENABLE_SERIAL
    | (1<<PRUSART0) // turn off USART
#endif //#ifndef ENABLE_SERIAL
    | 0;
}

uint16_t readLightLevel() {
  uint16_t Result = 0;
  pinMode(PHOTO_CELL_PIN, OUTPUT);
  pinMode(PHOTO_CELL_PIN, INPUT);
  pinMode(PHOTO_CELL_POWER, OUTPUT);
  digitalWrite(PHOTO_CELL_POWER, HIGH);
  delay(10);
  Result = 1024 - analogRead(PHOTO_CELL_PIN);
#ifndef ENABLE_SERIAL
  Serial.println("Current light level: ");
  Serial.print(Result);
#endif //#ifndef ENABLE_SERIAL
  // Setup the photo cell pins as input pins
  pinMode(PHOTO_CELL_POWER, INPUT);
  // Activate internal pull-down
  digitalWrite(PHOTO_CELL_POWER, LOW);
  digitalWrite(PHOTO_CELL_PIN, LOW);
  return Result;
}

// the setup routine runs once when you press reset:
void setup() {  
#ifdef ENABLE_SERIAL
  Serial.begin(115200);
  printf_begin();
  Serial.println("");
  Serial.println("=====================================");
  Serial.println("PIR Sensor Transmitter v0.5");
  Serial.println("=====================================");
  Serial.println("");
#endif //#ifdef ENABLE_SERIAL
  sensorData.nodeID = NODEID; // this node id should be the same for all devices in this node
  
  // initialize time
  pir_time = millis();
  
  // declare pin 9 to be an output:
  pinMode(STATUS_LED, OUTPUT);
  pinMode(PIR_INPUT, INPUT);
 
  digitalWrite(PIR_INPUT, LOW);
  
  // Setup the photo cell pins as input pins
  pinMode(PHOTO_CELL_PIN, OUTPUT);
  pinMode(PHOTO_CELL_POWER, OUTPUT);
  // Activate internal pull-down
  digitalWrite(PHOTO_CELL_PIN, LOW);
  digitalWrite(PHOTO_CELL_POWER, LOW);
  
  pinMode(LIGHT_THRESHOLD_PIN, INPUT);
  lightThreshold = analogRead(LIGHT_THRESHOLD_PIN);
  printf("Light Threshold set to %c: ", lightThreshold);
  //
  // Setup and configure rf radio
  //
  radio.begin();
  // set output level
  radio.setPALevel(RF24_PA_MIN);
  // optionally, increase the delay between retries & # of retries
  radio.setRetries(15, 5);
  radio.setAutoAck(true);
  // set CRC to 8 bit
  radio.setCRCLength(RF24_CRC_8);
  // set data rate to 250 Kbps
  radio.setDataRate(RF24_250KBPS);
  // set channel 15
  radio.setChannel(15);
  // optionally, reduce the payload size. seems to
  // improve reliability
  //radio.setPayloadSize(1);
  radio.setPayloadSize(sizeof(sensorData));
  //
  // Dump the configuration of the rf unit for debugging
  //
  radio.printDetails();
  //
  // Open pipes to other nodes for communication
  //
  openPipes();
  //////////////////////////////////////////////////////////////////////////
  // Setup the WDT interrupt
  //////////////////////////////////////////////////////////////////////////
  // Clear the reset flag.
  MCUSR &= ~(1<<WDRF);
  // In order to change WDE or the prescaler, we need to
  // set WDCE (This will allow updates for 4 clock cycles).
  WDTCSR |= (1<<WDCE) | (1<<WDE);
  // set new watchdog timeout prescaler value
  WDTCSR = 1<<WDP0 | 1<<WDP3; // 8.0 seconds
  // Enable the WD interrupt (note no reset).
  WDTCSR |= _BV(WDIE);
  //////////////////////////////////////////////////////////////////////////
  // Setup PIR interrupts
  //////////////////////////////////////////////////////////////////////////
  attachInterrupt(0, PIR_vect, FALLING);
  // attachInterrupt(1, processPIR, RISING);
  
#ifdef ENABLE_SERIAL
  Serial.println("");
  Serial.println("====================================");
  Serial.println("Setup complete. PIR Sensor is ready");
  Serial.println("====================================");
  Serial.println("");
  delay(200);
#endif //#ifdef ENABLE_SERIAL
}
// the loop routine runs over and over again forever:
void loop() {
  if (dataToSend != dataSent) {  
    pir_time = millis();
    sensorData.deviceID = 2;
    sensorData.var1_usl = millis();
    sensorData.var2_float = 1111;
    sensorData.var3_float = 1112; //null
    
//    if (readLightLevel() > lightThreshold) { 
    
#ifdef ENABLE_SERIAL
    printf("\r\nMotion detected! Sending data '%c' to receiver...", dataToSend);
#endif //#ifdef ENABLE_SERIAL

    //power up the radio first
    radio.powerUp();
    // First, stop listening so we can talk.
    radio.stopListening();
    delay(10);
    // Take the time, and send it. This will block until complete
    digitalWrite(ledTx, HIGH);
    delay(50);
    bool ok = radio.write( &dataToSend, sizeof(dataToSend) );
    //radio.write((const void*) (&sensorData), sizeof(sensorData));
    digitalWrite(ledTx, LOW);
    // Now, continue listening
    unsigned long started_waiting_at = millis();
    delay(10);
    radio.startListening();
    if(!ok) {
      Serial.println("Data Transmission error!");
      // blink LED several times in case of transmission error
      digitalWrite(ledTx, HIGH);
      delay(50);
      digitalWrite(ledTx, LOW);
      delay(30);
      digitalWrite(ledTx, HIGH);
      delay(50);
      digitalWrite(ledTx, LOW);
      delay(30);
      digitalWrite(ledTx, HIGH);
      delay(50);
      digitalWrite(ledTx, LOW);
    }
//    }
    radio.stopListening();
    delay(200);
    radio.powerDown();
     dataSent = dataToSend;
  } 
  else {
#ifdef ENABLE_SERIAL
    printf("\r\nSleeping...");
    delay(100);
#endif //#ifdef ENABLE_SERIAL

    //power down the sensor till next interrupt
    PowerDownSleep();
   
#ifdef ENABLE_SERIAL
  Serial.println("woke up");
#endif //#ifdef ENABLE_SERIAL
  }
}


